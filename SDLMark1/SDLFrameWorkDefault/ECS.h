#pragma once

#include <iostream>
#include <vector>
#include <memory>
#include <algorithm>
#include <bitset>
#include <array>
#include <string>

#include "imgui.h"

#include "BlackBoard.h"

class Entity;
class Component;

using ComponentID = std::size_t;

inline ComponentID getComponentTypeID()
{
	static ComponentID lastID = 0;
	return lastID++;
}

template <typename T> inline ComponentID getComponentTypeID() noexcept
{
	static ComponentID typeID = getComponentTypeID();
	return typeID;
}

// some useful "macros"
constexpr std::size_t maxComponents = 32;

using ComponentBitSet = std::bitset<maxComponents>;
using ComponentArray = std::array<Component*, maxComponents>;

/*!
	The base component used by the ECS system.

	ALL components must inherit from this class to be able to be added to an Entity.
*/
class Component
{
public:
	std::string name = "Look at this descriptive name!"; /*!< The name of a component. This is used for identification and MUST be unique to a component.*/

	Entity* entity; /*!< Reference to the entity this component is attached to. Allows for interaction between components.*/

	virtual void Init() {};			/*!< Base Init has no behaviour. This is called once after scene load.*/
	virtual void Tick() {};			/*!< Base Tick has no behaviour. This is called every frame in game-mode.*/
	virtual void EditorTick() {};	/*!< Base EditorTick has no behaviour. This is called every frame in edit-mode.*/

	virtual ~Component() {};

	virtual void PopulateInspector() {}; /*!< Base PopulateInspector has no behaviour. This is used to populate the inspector with editable fields / useful information.*/
	virtual std::string GetSaveData() { return ""; }; /*!< Base GetSaveData has no behaviour. This is used to generate the sava data needed to save a scene.*/
};

/*!
	An Entity is the base of every object inside FithyEngine.

	An entity is comprised of multiple Components, as well as some identifying features such as an ID, and name.

	EVERY entity will, by default, have a PositionComponent.
*/
class Entity
{
public:

	int ID; /*!< Unique ID assigned to this Entity.*/

	/*!
		Base constructor sets the ID number of the entity to one generated by the blackboard.
	*/
	Entity()
	{
		ID = BlackBoard::Instance()->getIDNumber();
	}

	std::string name = "What a creative name!"; /*!< Name of the entity.*/

	std::string tag = ""; /*!< Tag of the entity. Intended for use of the physics system and collisions.*/

	/*!
		Determines if the entity is in edit mode.
		
		\note This IS NOT the same as edit mode in the blackboard. THIS is used to determine that the entity has been selected whilst in edit mode, and is open for editing via inspector.
		\note Also changes behaviour in some components like collision component which will draw lines whilst it's entity is in edit mode.
	*/
	bool editMode;

	bool enabled = true; /*!< Determines if the entity is enables. Disabled entities are not ticked or collided with.*/

	/*!
		Initliazes the Entity.

		All components attached to this entity are initialized too.
	*/
	void Init()
	{
		for (auto& c : components)
		{
			c->Init();
		}
	}

	/*!
		Tick runs the tick function of all components attached to this entity.

		\note This DOES NOT tick the sprite component!!! Entities are drawn at the end of the frame, and the sprite component is ticked by Scene's Draw function.
	*/
	void Tick()
	{
		for (auto& c : components)
		{
			if (c->name != "SpriteComponent")
			{
				c->Tick();
			}
		}
	}

	/*!
		EditorTick runs the EditorTick function of all components attached to this entity.

		\note This DOES tick the sprite component's EditorTick function.
	*/
	void EditorTick()
	{
		for (auto& c : components)
		{
			c->EditorTick();
		}
	}

	bool isEnabled() const { return enabled; } /*!< QoL getter function for if an entity is enabled.*/

	const std::vector<std::shared_ptr<Component>> getComponents() { return components; } /*!< Gets a list of all components. Used to populate the inspector.*/

	/*!
		Checks the componentBitSet to see if an object has component of type T.

		\return Whether the component of type T has been found on this entity.
	*/
	template<typename T> bool hasComponent() const
	{
		return componentBitSet[getComponentTypeID<T>()];
	}

	/*!
		Add a component of type T to this Entity.
	*/
	template<typename T, typename... TArgs>
	T& addComponent(TArgs&& ... mArgs)
	{
		// TArgs&& is an Rvalue reference, a 'temporary' that is permitted to be modified after initialized for the purpose of 'move semantics'
		// https://en.wikipedia.org/wiki/C%2B%2B11#Rvalue_references_and_move_constructors
		// read that for a memory refresher ^^

		// create a new component of type T
		// std::forward allows the use of Rvalues in place of any other reference
		// this means we can create new components with generic arguments
		T* c(new T(std::forward<TArgs>(mArgs)...));
		// set component's entity to this
		c->entity = this;

		// create a smart pointer of our new component, and add it to the end (emplace_back) of our components vector
		std::unique_ptr<Component> uPtr{ c };
		components.emplace_back(std::move(uPtr));

		// upate array and bitset to reflect our new component
		componentArray[getComponentTypeID<T>()] = c;
		componentBitSet[getComponentTypeID<T>()] = true;

		// call init on the new component
		c->Init();
		return *c;
	}

	/*!
		Get a component of type T on this entity.

		\return A reference to the component of type T.

		\warning There is NO check for if an Entity has a component before it is gotten from the componentArray. If the component is not attached to this Entity, it WILL crash.
	*/
	template<typename T> T& getComponent() const
	{
		// auto is a generic chunk of data with no type
		// this allows us to grab any of our components without losing their typing
		auto ptr(componentArray[getComponentTypeID<T>()]);
		// static_cast will cast the ptr to type T, allowing us to still access all the juicy data
		return *static_cast<T*>(ptr);
	}

private:

	std::vector<std::shared_ptr<Component>> components; /*!< A list of all the components.*/

	ComponentArray componentArray; /*!< An array of component IDs attached to this entity.*/
	ComponentBitSet componentBitSet; /*!< A bitset for the components attached to this object.*/
};